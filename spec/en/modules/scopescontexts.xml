<?xml version="1.0" encoding="UTF-8"?>
<chapter id="contexts">
  <title>Scopes and contexts</title>

  <para>Associated with every scope type is a <emphasis>context object</emphasis>. 
  The context object determines the lifecycle and visibility of instances of all 
  beans with that scope. In particular, the context object defines:</para>
  
  <itemizedlist>
    <listitem>
      <para>When a new instance of any bean with that scope is created</para>
    </listitem>
    <listitem>
      <para>When an existing instance of any bean with that scope is 
      destroyed</para>
    </listitem>
    <listitem>
      <para>Which injected references refer to any instance of a bean with 
      that scope</para>
    </listitem>
  </itemizedlist>
  
  <para> The context implementation collaborates with the container via the 
  <literal>Context</literal> and <literal>Contextual</literal> interfaces to 
  create and destroy contextual instances.</para>

  <section id="contextual">
    <title>The <literal>Contextual</literal> interface</title>
    
    <para>The interface <literal>javax.enterprise.context.spi.Contextual</literal>  
    defines operations to create and destroy contextual instances of a certain type. 
    Any implementation of <literal>Contextual</literal> is called a  
    <emphasis>contextual type</emphasis>. In particular, the <literal>Bean</literal> 
    interface defined in <xref linkend="bean"/> extends <literal>Contextual</literal>, 
    so all beans are contextual types.</para>
    
    <programlisting><![CDATA[public interface Contextual<T> {
    public T create(CreationalContext<T> creationalContext);
    public void destroy(T instance, CreationalContext<T> creationalContext);
}]]></programlisting>

    <itemizedlist>
      <listitem>
        <para><literal>create()</literal> is responsible for creating new 
        contextual instances of the type.</para>
      </listitem>
      <listitem>
        <para><literal>destroy()</literal> is responsible for destroying 
        instances of the type. In particular, it is responsible for 
        destroying all dependent objects of an instance.</para>
      </listitem>
    </itemizedlist>

    <para>If an exception occurs while creating an instance, the exception is
    rethrown by the <literal>create()</literal> method. If the exception is a
    checked exception, it must be wrapped and rethrown as an (unchecked) 
    <literal>CreationException</literal>.</para>
    
    <para>If an exception occurs while destroying an instance, the exception 
    must be caught by the <literal>destroy()</literal> method.</para>
    
    <para>If the application invokes a contextual instance after it has been 
    destroyed, the behavior is undefined.</para>
    
    <para>The container and portable extensions may define implementations
    of the <literal>Contextual</literal> interface that do not extend 
    <literal>Bean</literal>, but it is not recommended that applications 
    directly implement <literal>Contextual</literal>.</para>
       
    <section id="creationalcontext">
      <title>The <literal>CreationalContext</literal> interface</title>
      
      <para>The interface <literal>javax.enterprise.context.spi.CreationalContext</literal>
      provides operations that are used by the <literal>Contextual</literal> 
      implementation during instance creation and destruction.</para>
      
      <programlisting><![CDATA[public interface CreationalContext<T> {
    public void push(T incompleteInstance);
    public void release();
}]]></programlisting>
     
      <itemizedlist>
        <listitem>
          <para><literal>push()</literal> registers an <emphasis>incompletely 
          initialized</emphasis> contextual instance the with the container. A 
          contextual instance is considered incompletely initialized until it
          is returned by the <literal>create()</literal> method.</para>
        </listitem>
        <listitem>
          <para><literal>release()</literal> destroys all dependent objects,
          as defined in <xref linkend="dependentobjects"/>,
          of the instance which is being destroyed, by passing each dependent
          object to the <literal>destroy()</literal> method of its 
          <literal>Contextual</literal> object.</para>
        </listitem>
      </itemizedlist>
      
      <para>The implementation of <literal>Contextual</literal> is not required to 
      call <literal>push()</literal>. However, for certain bean scopes, invocation 
      of <literal>push()</literal> between instantiation and injection helps the 
      container minimize the use of client proxy objects (which would otherwise be 
      required to allow circular dependencies).</para>
    
      <para>If <literal>Contextual.create()</literal> calls <literal>push()</literal>, 
      it must also return the instance passed to <literal>push()</literal>.</para>
      
      <para><literal>Contextual.create()</literal> should use the given 
      <literal>CreationalContext</literal> when obtaining contextual references to
      inject, as defined in <xref linkend="contextualreference"/>, in order to ensure 
      that any dependent objects are associated with the contextual instance that is 
      being created.</para>

      <para><literal>Contextual.destroy()</literal> should call <literal>release()</literal>
      to allow the container to destroy dependent objects of the contextual instance.</para>

    </section>

  </section>
  
  <section id="context">
    <title>The <literal>Context</literal> interface</title>
    
    <para>The <literal>javax.enterprise.context.spi.Context</literal> interface 
    provides an operation for obtaining contextual instances with a particular 
    scope of any contextual type. Any instance of <literal>Context</literal> is 
    called a context object.</para>

    <para>The context object is responsible for creating and destroying contextual
    instances by calling operations of the <literal>Contextual</literal> interface.</para>
    
    <para>The <literal>Context</literal> interface is called by the container and
    may be called by portable extensions. It should not be called directly by 
    the application.</para>
    
    <programlisting><![CDATA[public interface Context {
    public Class<? extends Annotation> getScope();
    boolean isActive();
    public <T> T get(Contextual<T> bean);
    public <T> T get(Contextual<T> bean, CreationalContext<T> creationalContext);
}]]></programlisting>

    <para>The method <literal>getScope()</literal> returns the scope type
    of the context object.</para>

    <para>At a particular point in the execution of the program a context object 
    may be <emphasis>active</emphasis> with respect to the current thread. When 
    a context object is active the <literal>isActive()</literal> method returns 
    <literal>true</literal>. Otherwise, we say that the context object is 
    <emphasis>inactive</emphasis> and the <literal>isActive()</literal> method 
    returns <literal>false</literal>.</para>
    
    <para>The <literal>get()</literal> method obtains contextual instances of the
    contextual type represented by the given instance of <literal>Contextual</literal>.   
    The <literal>get()</literal> method may either:</para>
    
    <itemizedlist>
      <listitem>
        <para>return an existing instance of the given contextual type, or</para>
      </listitem>
      <listitem>
        <para>if no <literal>CreationalContext</literal> is given, return a null 
        value, or</para>
      </listitem>
      <listitem>
        <para>if a <literal>CreationalContext</literal> is given, create a new 
        instance of the given contextual type by calling 
        <literal>Contextual.create()</literal>, passing the given 
        <literal>CreationalContext</literal>, and return the new instance.</para>
      </listitem>
    </itemizedlist>
    
    <para>If the context object is inactive, the <literal>get()</literal> method
    must throw a <literal>ContextNotActiveException</literal>.</para>

    <para>The <literal>get()</literal> method may not return a null value unless 
    no <literal>CreationalContext</literal> is given, or 
    <literal>Contextual.create()</literal> returns a null value.</para>
      
    <para>The <literal>get()</literal> method may not create a new instance of 
    the given contextual type unless a <literal>CreationalContext</literal> is 
    given.</para>
             
    <para>The context object is responsible for destroying any contextual instance 
    it creates by passing the instance to the <literal>destroy()</literal> method 
    of the <literal>Contextual</literal> object representing the contextual type. 
    A destroyed instance must not subsequently be returned by the <literal>get()</literal> 
    method.</para>
    
    <para>The context object must pass the same instance of 
    <literal>CreationalContext</literal> to <literal>Contextual.destroy()</literal> 
    that it passed to <literal>Contextual.create()</literal> when it created the 
    instance.</para>
    
  </section>

  <section id="normalscope">
    <title>Normal scopes and pseudo-scopes</title>

    <para>Most scopes are <emphasis>normal scopes</emphasis>. The context object
    for a normal scope type is a mapping from each contextual type with that scope 
    to an instance of that contextual type. There may be no more than one mapped 
    instance per contextual type per thread. The set of all mapped instances of 
    contextual types with a certain scope for a certain thread is called the 
    <emphasis>context</emphasis> for that scope associated with that thread.</para>
    
    <para>A context may be associated with one or more threads. A context with a 
    certain scope is said to <emphasis>propagate</emphasis> from one point in the 
    execution of the program to another when the set of mapped instances of contextual
    types with that scope is preserved.</para>
    
    <para>The context associated with the current thread is called the 
    <emphasis>current context</emphasis> for the scope. The mapped instance of a 
    contextual type associated with a current context is called the <emphasis>current 
    instance</emphasis> of the contextual type.</para>
        
    <para>The <literal>get()</literal> operation of the context object for an 
    active normal scope returns the current instance of the given contextual 
    type.</para>
    
    <para>At certain points in the execution of the program a context may be 
    <emphasis>destroyed</emphasis>. When a context is destroyed, all mapped 
    instances belonging to that context are destroyed by passing them to the 
    <literal>Contextual.destroy()</literal> method.</para>

    <para>Contexts with normal scopes must obey the following rule:</para>
  
    <para><emphasis>Suppose beans <literal>A</literal>, <literal>B</literal>
    and <literal>Z</literal> all have normal scopes. Suppose <literal>A</literal> 
    has an injection point <literal>x</literal>, and <literal>B</literal> has 
    an injection point <literal>y</literal>. Suppose further that both 
    <literal>x</literal> and <literal>y</literal> resolve to bean 
    <literal>Z</literal> according to the rules of typesafe resolution. If 
    <literal>a</literal> is the current instance of <literal>A</literal>, and 
    <literal>b</literal> is the current instance of <literal>B</literal>, then 
    both <literal>a.x</literal> and <literal>b.y</literal> refer to the same 
    instance of <literal>Z</literal>. This instance is the current instance of 
    <literal>Z</literal>.</emphasis></para>
  
    <para>Any scope that is not a normal scope is called a 
    <emphasis>pseudo-scope</emphasis>. The concept of a current instance is
    not well-defined in the case of a pseudo-scope.</para>
    
    <para>All normal scopes must be explicitly declared 
    <literal>@NormalScope</literal>, to indicate to the container that a 
    client proxy is required.</para>
    
    <para>All pseudo-scopes must be explicitly declared 
    <literal>@Scope</literal>, to indicate to the container that no 
    client proxy is required.</para>
    
    <para>All scopes defined by this specification, except for the
    <literal>@Dependent</literal> pseudo-scope, are normal scopes.</para>
    
  </section>
  
  <section id="dependentcontext">
    <title>Dependent pseudo-scope</title>
    
    <para>The <literal>@Dependent</literal> scope type is a pseudo-scope. Beans 
    declared with scope type <literal>@Dependent</literal> behave differently to 
    beans with other built-in scope types.</para>
    
    <para>When a bean is declared to have <literal>@Dependent</literal> 
    scope:</para>
    
    <itemizedlist>
      <listitem>
        <para>No injected instance of the bean is ever shared between multiple 
        injection points.</para>
      </listitem>
      <listitem>
        <para>Any instance of the bean injected into an object that is being 
        created by the container is bound to the lifecycle of the newly created 
        object.</para>
      </listitem>
      <listitem>
        <para>When a Unified EL expression in a JSF or JSP page that refers to 
        the bean by its EL name is evaluated, at most one instance of the bean 
        is instantiated. This instance exists to service just a single evaluation 
        of the EL expression. It is reused if the bean EL name appears multiple 
        times in the EL expression, but is never reused when the EL expression 
        is evaluated again, or when another EL expression is evaluated.</para>
      </listitem>
      <listitem>
        <para>Any instance of the bean that receives a producer method, producer 
        field, disposer method or observer method invocation exists to service 
        that invocation only.</para>
      </listitem>
      <listitem>
        <para>Any instance of the bean injected into method parameters of 
        a disposer method or observer method exists to service the method 
        invocation only (except for observer methods of container lifecycle
        events).</para>
      </listitem>
    </itemizedlist>
    
    <para>Every invocation of the <literal>get()</literal> operation of the 
    <literal>Context</literal> object for the <literal>@Dependent</literal> 
    scope with a <literal>CreationalContext</literal> returns a new instance 
    of the given bean.</para>
    
    <para>Every invocation of the <literal>get()</literal> operation of the 
    <literal>Context</literal> object for the <literal>@Dependent</literal> 
    scope with no <literal>CreationalContext</literal> returns a null value.</para>
    
    <para>The <literal>@Dependent</literal> scope is always active.</para>
    
    <!--  
    <section>
      <title>Dependent scope lifecycle</title>
    
      <para>The <literal>@Dependent</literal> scope is active when:</para>
    
      <itemizedlist>
        <listitem>
          <para>
            the container is creating a contextual instance of a bean, injecting 
            its dependencies and creating its decorators, or
          </para>
        </listitem>
        <listitem>
          <para>
            the container is injecting dependencies of a Java EE component class 
            supporting injection, or
          </para>
        </listitem>
        <listitem>
          <para>
            a contextual instance of a bean with scope <literal>@Dependent</literal> 
            is created by the container to receive a producer method, producer field, 
            disposer method or observer method invocation, or
          </para>
        </listitem>
        <listitem>
          <para>
            an observer or disposer method is invoked, or
          </para>
        </listitem>
        <listitem>
          <para>
            a Unified EL expression is evaluated, or
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>Instance.get()</literal>, <literal>Instance.iterator().next()</literal> 
            or <literal>BeanManager.getReference()</literal> is invoked upon an 
            instance of <literal>Instance</literal> or <literal>BeanManager</literal> 
            injected by the container into a bean or other Java EE component class 
            supporting injection.
          </para>
        </listitem>
      </itemizedlist>
    </section>
    -->
      <!--
      <para>The <literal>@Dependent</literal> scope is even active 
      during invocation of interceptors and decorators of observer methods 
      and interceptors and decorators of <literal>@PostConstruct</literal> 
      and <literal>@PreDestroy</literal> callbacks.</para>
      -->
    
      <!--
      <para>The <literal>@Dependent</literal> scope is not active when 
      <literal>Instance.get()</literal>, <literal>Instance.iterator()</literal> 
      or <literal>BeanManager.getReference().next()</literal> is invoked upon an 
      instance of <literal>Instance</literal> or <literal>BeanManager</literal> 
      that was not injected by the container.</para>
      -->    
    
    <section id="dependentobjects">
      <title>Dependent objects</title>
            
      <para>Many instances of beans with scope <literal>@Dependent</literal> belong 
      to some other bean or Java EE component class instance and are called 
      <emphasis>dependent objects</emphasis>.</para>
      
      <itemizedlist>
      <listitem>
        <para>Instances of decorators and interceptors are dependent objects of the 
        bean instance they decorate.</para>
      </listitem>
      <listitem>
        <para>An instance of a bean with scope <literal>@Dependent</literal> injected 
        into a field, bean constructor or initializer method is a dependent object of 
        the bean or Java EE component class instance into which it was injected.</para>
      </listitem>
      <listitem>
        <para>An instance of a bean with scope <literal>@Dependent</literal> injected 
        into a producer method is a dependent object of the producer method bean 
        instance that is being produced.</para>
      </listitem>
      <listitem>
        <para>An instance of a bean with scope <literal>@Dependent</literal> obtained 
        by direct invocation of an <literal>Instance</literal> is a dependent object 
        of the instance of <literal>Instance</literal>.</para>
      </listitem>
      </itemizedlist>
      
      <!--
      <para>Dependent objects of a contextual instance are associated with the 
      <literal>CreationalContext</literal> of the contextual instance. (The 
      <literal>CreationalContext</literal> passed to <literal>Contextual.get()</literal>
      when the contextual instance was created.)</para>
      -->
      
    </section>
    
    <section id="dependentdestruction">
      <title>Destruction of objects with scope <literal>@Dependent</literal></title>
      
      <para>Dependent objects of a contextual instance are destroyed when 
      <literal>Contextual.destroy()</literal> calls 
      <literal>CreationalContext.release()</literal>, as defined in 
      <xref linkend="creationalcontext"/>.</para>
      
      <para>Additionally, the container must ensure that:</para>
      
      <itemizedlist>
        <listitem>
          <para>all dependent objects of a non-contextual instance of a bean or 
          other Java EE component class are destroyed when the instance is 
          destroyed by the container,</para>
        </listitem>
        <listitem>
          <para>all <literal>@Dependent</literal> scoped contextual instances 
          injected into method parameters of an observer method of any container 
          lifecycle event, as defined in <xref linkend="initevents"/>, is destroyed
          after all observers of the <literal>BeforeShutdown</literal> event 
          complete,</para>
        </listitem>
        <listitem>
          <para>all <literal>@Dependent</literal> scoped contextual instances 
          injected into method parameters of a disposer method or observer method 
          of any other event are destroyed when the invocation completes,</para>
        </listitem>
        <listitem>
          <para>any <literal>@Dependent</literal> scoped contextual instance 
          created to receive a producer method, producer field, disposer method 
          or observer method invocation is destroyed when the invocation completes, 
          and</para>
        </listitem>
        <listitem>
          <para>all <literal>@Dependent</literal> scoped contextual instances 
          created during evaluation of a Unified EL expression in a JSP or JSF page 
          are destroyed when the evaluation completes.</para>
         </listitem>
      </itemizedlist>
      
      <para>Finally, the container is permitted to destroy any <literal>@Dependent</literal> 
      scoped contextual instance at any time if the instance is no longer referenced 
      by the application (excluding weak, soft and phantom references).</para>
      
    </section>
    
    <section id="dependentscopeel">
      <title>Dependent pseudo-scope and Unified EL</title>
      
      <para>Suppose a Unified EL expression in a JSF or JSP page refers to a bean with scope 
      <literal>@Dependent</literal> by its EL name. Each time the EL expression is evaluated:</para>
    
      <itemizedlist>
      <listitem>
        <para>the bean is instantiated at most once, and</para>
      </listitem>
      <listitem>
        <para>the resulting instance is reused for every appearance of the EL name, 
        and</para>
      </listitem>
      <listitem>
        <para>the resulting instance is destroyed when the evaluation completes.</para>
      </listitem>
      </itemizedlist>
      
      <para>Portable extensions that integrate with the container via Unified EL should 
      also ensure that these rules are enforced.</para>
      
    </section>
    
  </section>
  
  <section>
    <title>Contextual instances and contextual references</title>
    
    <para>The <literal>Context</literal> object is the ultimate
    source of the contextual instances that underly contextual
    references.</para>
  
  <section id="activecontext">
    <title>The active context object for a scope</title>
    
    <para>From time to time, the container must obtain an <emphasis>active context 
    object</emphasis> for a certain scope type. The container must search for an 
    active instance of <literal>Context</literal> associated with the scope type.</para>
    
    <itemizedlist>
      <listitem>
        <para>If no active context object exists for the scope type, the container 
        throws a <literal>ContextNotActiveException</literal>.</para>
      </listitem>
      <listitem>
        <para>If more than one active context object exists for the given scope type, 
        the container must throw an <literal>IllegalStateException</literal>.</para>
      </listitem>
    </itemizedlist>
    
    <para>If there is exactly one active instance of <literal>Context</literal> 
    associated with the scope type, we say that the scope is 
    <emphasis>active</emphasis>.</para>
    
  </section>
  
  <section id="contextualinstance">
    <title>Contextual instance of a bean</title>
    
    <para>From time to time, the container must obtain a <emphasis>contextual 
    instance</emphasis> of a bean. The container must:</para>
    
    <itemizedlist>
      <listitem>
        <para>obtain the active context object for the bean scope, then</para>
      </listitem>
      <listitem>
        <para>obtain an instance of the bean by calling <literal>Context.get()</literal>, 
        passing the <literal>Bean</literal> instance representing the bean and 
        an instance of <literal>CreationalContext</literal>.</para>
      </listitem>
    </itemizedlist>
    
    <para>From time to time, the container attempts to obtain a <emphasis>contextual 
    instance of a bean that already exists</emphasis>, without creating a new
    contextual instance. The container must determine if the scope of the bean is 
    active and if it is:</para>
    
    <itemizedlist>
      <listitem>
        <para>obtain the active context object for the bean scope, then</para>
      </listitem>
      <listitem>
        <para>attempt to obtain an existing instance of the bean by calling 
        <literal>Context.get()</literal>, passing the <literal>Bean</literal> 
        instance representing the bean without passing any instance of 
        <literal>CreationalContext</literal>.</para>
      </listitem>
    </itemizedlist>
    
    <para>If the scope is not active, or if <literal>Context.get()</literal> returns
    a null value, there is no contextual instance that already exists.</para>
        
    <para>A contextual instance of any of the built-in kinds of bean defined in 
    <xref linkend="implementation"/> is considered an internal container construct, 
    and it is therefore not strictly required that a contextual instance of a 
    built-in kind of bean directly implement the bean types of the bean. However, 
    in this case, the container is required to transform its internal representation 
    to an object that does implement the bean types expected by the application 
    before injecting or returning a contextual instance to the application.</para>
    
    <para>For a custom implementation of the <literal>Bean</literal> interface
    defined in <xref linkend="bean"/>, the container calls 
    <literal>getScope()</literal> to determine the bean scope.</para>
    
  </section>
  
  <section id="contextualreference">
    <title>Contextual reference for a bean</title>
    
    <para>From time to time, the container must obtain a <emphasis>contextual 
    reference</emphasis> for a bean and a given bean type of the bean. A
    contextual reference implements the given bean type and all bean types of 
    the bean which are Java interfaces. A contextual reference is not, in 
    general, required to implement all concrete bean types of the bean.</para>
    
    <para>Contextual references must be obtained with a given
    <literal>CreationalContext</literal>, allowing any instance of scope
    <literal>@Dependent</literal> that is created to be later destroyed.</para>
    
    <itemizedlist>
      <listitem>
        <para>If the bean has a normal scope and the given bean type
        cannot be proxied by the container, as defined in 
        <xref linkend="unproxyable"/>, the container throws an 
        <literal>UnproxyableResolutionException</literal>.
        </para>
      </listitem>
      <listitem>
        <para>If the bean has a normal scope, then the contextual reference 
        for the bean is a client proxy, as defined in 
        <xref linkend="clientproxies"/>, created by the 
        container, that implements the given bean type and all bean types of 
        the bean which are Java interfaces.</para>
      </listitem>
      <listitem>
        <para>Otherwise, if the bean has a pseudo-scope, the container must 
        obtain a contextual instance of the bean. If the bean has scope
        <literal>@Dependent</literal>, the container must associate it with
        the <literal>CreationalContext</literal>.</para>
      </listitem>
    </itemizedlist>
    
    <para>The container must ensure that every injection point of type 
    <literal>InjectionPoint</literal> and qualifier <literal>@Default</literal> 
    of any dependent object instantiated during this process receives:</para>
    
    <itemizedlist>
      <listitem>
        <para> 
        an instance of <literal>InjectionPoint</literal> representing the 
        injection point into which the dependent object will be injected, 
        or</para>
      </listitem> 
      <listitem>
        <para>
        a null value if it is not being injected into any injection point.</para>
      </listitem>
    </itemizedlist>
    
  </section>
  
  <section>
    <title>Contextual reference validity</title>
    
    <para>A contextual reference for a bean is <emphasis>valid</emphasis>
    only for a certain period of time. The application should not invoke
    a method of an invalid reference.</para>
    
    <para>The validity of a contextual reference for a bean depends upon 
    whether the scope of the bean is a normal scope or a pseudo-scope.</para>
    
    <itemizedlist>
      <listitem>
        <para>Any reference to a bean with a normal scope is valid as 
        long as the application maintains a hard reference to it. However, 
        it may only be invoked when the context associated with the normal 
        scope is active. If it is invoked when the context is inactive, a 
        <literal>ContextNotActiveException</literal> is thrown by the 
        container.</para>
      </listitem>
      <listitem>
        <para>Any reference to a bean with a pseudo-scope (such as 
        <literal>@Dependent</literal>) is valid until the bean instance 
        to which it refers is destroyed. It may be invoked even if the context 
        associated with the pseudo-scope is not active. If the application
        invokes a method of a reference to an instance that has already been
        destroyed, the behavior is undefined.</para>
      </listitem>
    </itemizedlist>
    
  </section>
  
    <section id="injectableinstance">
      <title>Injectable references</title>
    
      <para>From time to time, the container must obtain an 
      <emphasis>injectable reference</emphasis> for an injection point. The 
      container must:</para>
    
      <itemizedlist>
    
        <listitem>
          <para>Identify a bean according to the rules defined in 
          <xref linkend="typesaferesolution"/> and resolving ambiguities
          according to <xref linkend="ambigdependencies"/>.</para>
        </listitem>
        
        <listitem>
          <para>Obtain a contextual reference for this bean and
          the type of the injection point according to 
          <xref linkend="contextualreference"/>.</para>
        </listitem>
      
      </itemizedlist>
      
      <!--  
      <para>Normally, typesafe resolution results in exactly one bean, since
      the container validated dependencies at initialization time.</para>
      -->
      
      <para>For certain combinations of scopes, the container is permitted
      to optimize the above procedure:</para>
      
      <itemizedlist>
      
        <listitem>
          <para>The container is permitted to directly inject a contextual 
          instance of the bean, as defined in 
          <xref linkend="contextualinstance"/>.</para>
        </listitem>

        <listitem>
          <para>If an incompletely initialized instance of the bean is 
          registered with the current <literal>CreationalContext</literal>, 
          as defined in <xref linkend="contextual"/>, the container is
          permitted to directly inject this instance.</para>
        </listitem>
      
      </itemizedlist>

      <para>However, in performing these optimizations, the container must 
      respect the rules of <emphasis>injectable reference validity</emphasis>.</para>
    
    </section>
    
    <section>
      <title>Injectable reference validity</title>
      
      <para>Injectable references to a bean must respect the rules of contextual 
      reference validity, with the following exceptions:</para>
      
      <itemizedlist>
        <listitem>
          <para>A reference to a bean injected into a field, bean constructor
          or initializer method is only valid until the object into which it was 
          injected is destroyed.</para>
        </listitem>
        <listitem>
          <para>A reference to a bean injected into a producer method is
          only valid until the producer method bean instance that is being
          produced is destroyed.</para>
        </listitem>
        <listitem>
          <para>A reference to a bean injected into a disposer method or
          observer method is only valid until the invocation of the method
          completes.</para>
        </listitem>
      </itemizedlist>
            
      <para>The application should not invoke a method of an invalid injected 
      reference. If the application invokes a method of an invalid injected 
      reference, the behavior is undefined.</para>
      
    </section>
        
  </section>
  
  <section id="passivatingscope">
    <title>Passivation and passivating scopes</title>
    
    <para>The temporary transfer of the state of an idle object held in memory 
    to some form of secondary storage is called <emphasis>passivation</emphasis>. 
    The transfer of the passivated state back into memory is called 
    <emphasis>activation</emphasis>.</para>
    
    <section id="passivationcapable">
      <title>Passivation capable beans</title>
    
      <para>A bean is called <emphasis>passivation capable</emphasis> if the 
      container is able to temporarily transfer the state of any idle instance 
      to secondary storage.</para>
    
      <itemizedlist>
      <listitem>
        <para>As defined by the EJB specification, all stateful session beans
        are passivation capable. Stateless and singleton session beans are
        not passivation capable.</para>
      </listitem>
      <listitem>
        <para>A managed bean is passivation capable if and only if the bean
        class is serializable and all interceptors and decorators of the bean
        are serializable.</para>
      </listitem>
      <listitem>
        <para>A producer method is passivation capable if and only if it never
        returns a value which is not passivation capable at runtime.</para>
      </listitem>
      <listitem>
        <para>A producer field is passivation capable if and only if it never
        refers to a value which is not passivation capable at runtime.</para>
      </listitem>
      </itemizedlist>
    
      <!--
      <para>A custom implementation of <literal>Bean</literal> is passivation
      capable if <literal>isPassivationCapable()</literal> returns 
      <literal>true</literal>.</para>
      -->
    
      <para>A custom implementation of <literal>Bean</literal> is passivation capable 
      if it implements the interface <literal>PassivationCapable</literal>. An
      implementation of <literal>Contextual</literal> that is not a bean is
      passivation capable if it implements both <literal>PassivationCapable</literal>
      and <literal>Serializable</literal>.</para>
      
      <programlisting><![CDATA[public interface PassivationCapable {
    public String getId();
}]]></programlisting>

      <para>The <literal>getId()</literal> method must return a value that uniquely
      identifies the instance of <literal>Bean</literal> or 
      <literal>Contextual</literal>. It is recommended that the string contain the
      package name of the class that implements <literal>Bean</literal> or
      <literal>Contextual</literal>.</para>
      
    </section>
  
    <section id="passivationcapabledependency">
      <title>Passivation capable dependencies</title>
    
      <para>A bean is called a <emphasis>passivation capable dependency</emphasis> 
      if any contextual reference for that bean is preserved when the object holding
      the reference is passivated and then activated.</para>
    
      <para>The container must guarantee that:</para>
    
      <itemizedlist>
        <listitem>
          <para>all session beans are passivation capable dependencies,</para>
        </listitem>
        <listitem>
          <para>all beans with normal scope are passivation capable dependencies,</para>
        </listitem>
        <listitem>
          <para>all passivation capable beans with scope <literal>@Dependent</literal> 
          are passivation capable dependencies,</para>
        </listitem>
        <listitem>
          <para>all resources <!--and message destinations--> are passivation capable 
          dependencies, and</para>
        </listitem>
        <listitem>
          <para>the built-in beans of type <literal>Instance</literal>, 
          <literal>Event</literal>, <literal>InjectionPoint</literal> and 
          <literal>BeanManager</literal> are passivation capable dependencies.</para> 
        </listitem>
      </itemizedlist>
    
      <para>A custom implementation of <literal>Bean</literal> is a passivation
      capable dependency if it implements <literal>PassivationCapable</literal> or if
      <literal>getScope()</literal> returns a normal scope type.</para>
    
    </section>
  
    <section>
      <title>Passivating scopes</title>

      <para>A <emphasis>passivating scope</emphasis> requires that:</para>
      
      <itemizedlist>
        <listitem>
          <para>beans with the scope are passivation capable, and</para>
        </listitem>
        <listitem>
          <para>implementations of <literal>Contextual</literal> passed to
          any context object for the scope are passivation capable.</para>
        </listitem>
      </itemizedlist> 
      
      <para>Passivating scopes must be explicitly declared 
      <literal>@NormalScope(passivating=true)</literal>.</para>
    
      <para>For example, the built-in session and conversation scopes defined in
      <xref linkend="builtincontexts"/> are passivating scopes. No other built-in
      scopes are passivating scopes.</para>

    </section>

    <section>
      <title>Validation of passivation capable beans and dependencies</title>
    
      <para>For every bean which declares a passivating scope, the container must
      validate that the bean truly is passivation capable and that, in addition, its
      dependencies are passivation capable.</para>
    
      <para>If a managed bean which declares a passivating scope:</para>
    
      <itemizedlist>
        <listitem>
          <para>is not passivation capable,</para>
        </listitem>
        <listitem>
          <para>has a non-transient injected field that does not resolve to a passivation
          capable dependency, or</para>
        </listitem>
        <listitem>
          <para>has an interceptor or decorator with a non-transient injected field
          that does not resolve to a passivation capable dependency,</para>
        </listitem>
      </itemizedlist> 
    
      <para>then the container automatically detects the problem and treats it 
      as a deployment problem.</para>
    
      <para>If a stateful session bean:</para>
    
      <itemizedlist>
        <listitem>
          <para>has a non-transient injected field that does not resolve to a
          passivation capable dependency, or</para>
        </listitem>
        <listitem>
          <para>has an interceptor or decorator with a non-transient injected field
          that does not resolve to a passivation capable dependency,</para>
        </listitem>
      </itemizedlist> 
    
      <para>then the container automatically detects the problem and treats it 
      as a deployment problem.</para>
    
      <para>If a producer method declares a passivating scope and has a return type
      that is declared final and does not implement or extend <literal>Serializable</literal>
      then the container automatically detects the problem and treats it
      as a deployment problem.</para>

      <para>If a producer method declares a passivating scope and doesn't only return
      <literal>Serializable</literal> types at runtime, then the container must throw
      an <literal>IllegalProductException</literal>.</para>

      <para>If a producer field declares a passivating scope and has a type that
      is declared final and does not implement or extend <literal>Serializable</literal>
      then the container automatically detects the problem and treats it
      as a deployment problem.</para>

      <para>If a producer field declares a passivating scope and doesn't only contain
      <literal>Serializable</literal> values at runtime then the container
      must throw an <literal>IllegalProductException</literal>.</para>

      <para>If a producer method or field of scope <literal>@Dependent</literal> returns
      an unserializable object for injection into an injection point that requires
      a passivation capable dependency, the container must throw an
      <literal>IllegalProductException</literal></para>

      <para>For a custom implementation of <literal>Bean</literal>, the container
      calls <literal>getInjectionPoints()</literal> to determine the injection 
      points, and <literal>InjectionPoint.isTransient()</literal> to determine 
      whether the injection point is a transient field.</para>
    
      <para>If a bean which declares a passivating scope type, or any stateful
      session bean, has a decorator or interceptor which is not a
      passivation capable dependency, the container automatically detects
      the problem and treats it as a deployment problem.</para>
    
    </section>
    
  </section>
  
  <section id="builtincontexts">
    <title>Context management for built-in scopes</title>

    <para>The container provides an implementation of the <literal>Context</literal>
    interface for each of the built-in scopes.</para>
    
    <para>The built-in request and application context objects are active during servlet,
    web service and EJB invocations, and the built in session and request context objects 
    are active during servlet and web service invocations. For other kinds of invocations,
    a portable extension may define a custom context object for any or all of the built-in
    scopes. For example, a remoting framework might provide a request context object for 
    the built-in request scope.</para>
    
    <para>The context associated with a built-in normal scope propagates across 
    local, synchronous Java method calls, including invocation of EJB local business 
    methods. The context does not propagate across remote method invocations or to 
    asynchronous processes such as JMS message listeners or EJB timer service 
    timeouts.</para>
    
    <section>
      <title>Request context lifecycle</title>

      <para>The <emphasis>request context</emphasis> is provided by a built-in context 
      object for the built-in scope type <literal>@RequestScoped</literal>. The request 
      scope is active:</para>
      
      <itemizedlist>
        <listitem>
          <para>during the <literal>service()</literal> method of any servlet in the 
          web application, during the <literal>doFilter()</literal> method of any 
          servlet filter and when the container calls any 
          <literal>ServletRequestListener</literal> or <literal>AsyncListener</literal>,</para>
        </listitem>
        <listitem>
          <para>during any Java EE web service invocation,</para>
        </listitem>
        <!--
        <listitem>
          <para>during any asynchronous observer method notification,</para>
        </listitem>
        -->
        <listitem>
          <para>during any remote method invocation of any EJB, during any asynchronous 
          method invocation of any EJB, during any call to an EJB timeout method and 
          during message delivery to any EJB message-driven bean, and</para>
        </listitem>
        <listitem>
          <para>during any message delivery to a <literal>MessageListener</literal> 
          for a JMS topic or queue obtained from the Java EE component environment.</para>
        </listitem>
      </itemizedlist>
      
      <para>The request context is destroyed:</para>
            
      <itemizedlist>
        <listitem>
          <para>at the end of the servlet request, after the <literal>service()</literal> 
          method, all <literal>doFilter()</literal> methods, and all 
          <literal>requestDestroyed()</literal> and <literal>onComplete()</literal> 
          notifications return,</para>
        </listitem>
        <listitem>
          <para>after the web service invocation completes,</para>
        </listitem>
        <!--
        <listitem>
          <para>after the asynchronous observer notification completes,</para>
        </listitem>
        -->
        <listitem>
          <para>after the EJB remote method invocation, asynchronous method invocation, 
          timeout or message delivery completes, or</para>
        </listitem>
        <listitem>
          <para>after the message delivery to the <literal>MessageListener</literal>
          completes.</para>
        </listitem>
      </itemizedlist>
      
      <para>An event with qualifier <literal>@Initialized(RequestScoped.class)</literal>
        is fired when the request context is initialized and an event with qualifier
        <literal>@Destroyed(RequestScoped.class)</literal> when the request context
        is destroyed. The event payload is:</para>
      
      <itemizedlist>
        <listitem>
          <para>the <literal>ServletRequestEvent</literal> if the context is initialized or destroyed 
          due to a servlet request, or</para>
        </listitem>
        <listitem>
          <para>the <literal>ServletRequestEvent</literal> if the context is initialized or destroyed 
          due to a web service invocation, or</para>
        </listitem>
        <listitem>
          <para>the <literal>???</literal> if the context is initialized or destroyed 
          due to a EJB remote method invocation, asynchronous method invocation, 
          timeout or message delivery, or</para>
        </listitem>
        <listitem>
          <para>the <literal>???</literal> if the context is initialized or destroyed 
          due to a message delivery to a <literal>MessageListener</literal>.</para>
        </listitem>
      </itemizedlist>
      
    </section>

    <section id="sessioncontext">
      <title>Session context lifecycle</title>

      <para>The <emphasis>session context</emphasis> is provided by a built-in 
      context object for the built-in passivating scope type 
      <literal>@SessionScoped</literal>. The session scope is active:</para>
      
      <itemizedlist>
        <listitem>
          <para>during the <literal>service()</literal> method of any servlet in the 
          web application, during the <literal>doFilter()</literal> method of any 
          servlet filter and when the container calls any 
          <literal>HttpSessionListener</literal>, <literal>AsyncListener</literal> 
          or <literal>ServletRequestListener</literal>.</para>
        </listitem>
        <!--listitem>
          <para>when the disposer method or <literal>@PreDestroy</literal> callback 
          of any bean with scope <literal>@RequestScoped</literal> or 
          <literal>@ConversationScoped</literal> is called during a servlet request.</para>
        </listitem-->
      </itemizedlist>

      <para>The session context is shared between all servlet requests that occur in 
      the same HTTP session. The session context is destroyed when the
      <literal>HTTPSession</literal> times out, after all <literal>HttpSessionListener</literal>s 
      have been called, and at the very end of any request in which <literal>invalidate()</literal> 
      was called, after all filters and <literal>ServletRequestListener</literal>s
      have been called.</para>
      
      <para>An event with the <literal>HttpSessionEvent</literal> as payload and with 
      qualifier <literal>@Initialized(SessionScoped.class)</literal> is fired when the 
      session context is initialized and an event with qualifier 
      <literal>@Destroyed(SessionScoped.class)</literal> when the session context
      is destroyed.</para>
      
    </section>

    <section>
      <title>Application context lifecycle</title>

      <para>The <emphasis>application context</emphasis> is provided by a built-in 
      context object for the built-in scope type <literal>@ApplicationScoped</literal>. 
      The application scope is active:</para>
      
      <itemizedlist>
        <listitem>
          <para>during the <literal>service()</literal> method of any servlet in 
          the web application, during the <literal>doFilter()</literal> method 
          of any servlet filter and when the container calls any 
          <literal>ServletContextListener</literal>,
          <literal>HttpSessionListener</literal>, <literal>AsyncListener</literal> 
          or <literal>ServletRequestListener</literal>,</para>
        </listitem>
        <listitem>
          <para>during any Java EE web service invocation, </para>
        </listitem>
        <!--
        <listitem>
          <para>during any asynchronous observer method notification,</para>
        </listitem>
        -->
        <listitem>
          <para>during any remote method invocation of any EJB, during any 
          asynchronous method invocation of any EJB, during any call to an EJB 
          timeout method and during message delivery to any EJB message-driven 
          bean,</para>
        </listitem>
        <listitem>
          <para>during any message delivery to a <literal>MessageListener</literal> 
          for a JMS topic or queue obtained from the Java EE component environment, 
          and</para>
        </listitem>
        <listitem>
          <para>when the disposer method or <literal>@PreDestroy</literal> 
          callback of any bean with any normal scope other than 
          <literal>@ApplicationScoped</literal> is called.</para>
        </listitem>
      </itemizedlist>
      
      <para>The application context is shared between all servlet requests,
      <!--asynchronous observer method notifications,--> web service invocations, 
      EJB remote method invocations, EJB asynchronous method invocations, EJB 
      timeouts and message deliveries to message-driven beans that execute 
      within the same application. The application context is destroyed when 
      the application is shut down.</para>
      
      <para>An event with qualifier <literal>@Initialized(ApplicationScoped.class)</literal>
      is fired when the application context is initialized and an event with qualifier 
      <literal>@Destroyed(ApplicationScoped.class)</literal> is fired when the 
      application is destroyed. The event payload is:</para>
      
      <itemizedlist>
         <listitem>
            <para>the <literal>ServletContextEvent</literal> if the application is a web application
            deployed to a Servlet container, or</para>
         </listitem>
         <listitem>
            <para>the <literal>???</literal> in ???</para>
         </listitem>
      </itemizedlist>

    </section>

    <section id="conversationcontext">
      <title>Conversation context lifecycle</title>

      <para>The <emphasis>conversation context</emphasis> is provided by a 
      built-in context object for the built-in passivating scope type 
      <literal>@ConversationScoped</literal>. The conversation scope is 
      active during all Servlet requests.</para>
      
      <para>An event with the <literal>ServletRequestEvent</literal> as the payload and with qualifier 
      <literal>@Initialized(ConversationContext.class)</literal> is fired when the 
      conversation context is initialized and an event with qualifier 
      <literal>@Destroyed(ConversationContext.class)</literal> when the conversation context
      is destroyed.</para>

      <para>The conversation context provides access to state associated with 
      a particular <emphasis>conversation</emphasis>. Every Servlet request has an
      associated conversation. This association is managed automatically by
      the container according to the following rules:</para>

      <itemizedlist>
        <listitem>
          <para>Any Servlet request has exactly one associated conversation.</para>
        </listitem>
        <listitem>
          <para>The conversation associated with a Servlet request is determined at 
          the beginning of the request before calling any <literal>service()</literal>
          method of any servlet in the web application, calling the
          <literal>doFilter()</literal> method of any servlet filter in the web application
          and before the container calls any <literal>ServletRequestListener</literal> 
          or <literal>AsyncListener</literal> in the web application.</para>
        </listitem>
      </itemizedlist>

      <para>Any conversation is in one of two states: <emphasis>transient</emphasis> 
      or <emphasis>long-running</emphasis>.</para>

      <itemizedlist>
        <listitem>
          <para>By default, a conversation is transient</para>
        </listitem>
        <listitem>
          <para>A transient conversation may be marked long-running by calling
          <literal>Conversation.begin()</literal></para>
        </listitem>
        <listitem>
          <para>A long-running conversation may be marked transient by calling
          <literal>Conversation.end()</literal></para>
        </listitem>
      </itemizedlist>

      <para>All long-running conversations have a string-valued unique 
      identifier, which may be set by the application when the conversation
      is marked long-running, or generated by the container.</para>

      <para>If the conversation associated with the current Servlet request is in
      the <emphasis>transient</emphasis> state at the end of a Servlet request, it
      is destroyed, and the conversation context is also destroyed.</para>

      <para>If the conversation associated with the current Servlet request is in
      the <emphasis>long-running</emphasis> state at the end of a Servlet request,
      it is not destroyed. The long-running conversation associated with a request 
      may be propagated to any Servlet request via use of a request parameter 
      named <literal>cid</literal> containing the unique identifier of the 
      conversation. In this case, the application must manage this request 
      parameter.</para>
      
      
      <para>If the current Servlet request is a JSF request, and the conversation 
      is in <emphasis>long-running</emphasis> state, it is propagated according 
      to the following rules:</para>

      <itemizedlist>
        <listitem>
          <para>The long-running conversation context associated with a
          request that renders a JSF view is automatically propagated to any
          faces request (JSF form submission) that originates from that
          rendered page.</para>
        </listitem>
        <listitem>
          <para>The long-running conversation context associated with a
          request that results in a JSF redirect (a redirect resulting from a 
          navigation rule or JSF <literal>NavigationHandler</literal>) is
          automatically propagated to the resulting non-faces request, and to
          any other subsequent request to the same URL. This is accomplished
          via use of a request parameter named <literal>cid</literal> 
          containing the unique identifier of the conversation.</para>
        </listitem>
      </itemizedlist>
      
      <para>When no conversation is propagated to a Servlet request, or if a 
      request parameter named <literal>conversationPropagation</literal>
      has the value <literal>none</literal> the request is associated with a
      new transient conversation.</para>

      <para>All long-running conversations are scoped to a particular HTTP 
      servlet session and may not cross session boundaries.</para>
      
      <para>In the following cases, a propagated long-running conversation cannot 
      be restored and reassociated with the request:</para>

      <itemizedlist>
        <listitem>
          <para>When the HTTP servlet session is invalidated, all long-running
          conversation contexts created during the current session are destroyed, 
          after the servlet <literal>service()</literal> method completes.</para>
        </listitem>
        <listitem>
          <para>The container is permitted to arbitrarily destroy any long-running 
          conversation that is associated with no current Servlet request, in order to 
          conserve resources.</para>
        </listitem>
      </itemizedlist>

      <para>The <emphasis>conversation timeout</emphasis>, which may be specified
      by calling <literal>Conversation.setTimeout()</literal> is a hint to the 
      container that a conversation should not be destroyed if it has been active 
      within the last given interval in milliseconds.</para>
      
      <para>If the propagated conversation cannot be restored, the container must 
      associate the request with a new transient conversation and throw an 
      exception of type 
      <literal>javax.enterprise.context.NonexistentConversationException</literal>.</para>
      
      <para>The container ensures that a long-running conversation may be 
      associated with at most one request at a time, by blocking or rejecting 
      concurrent requests. If the container rejects a request, it must associate
      the request with a new transient conversation and throw an exception of type 
      <literal>javax.enterprise.context.BusyConversationException</literal>.</para>

    </section>
    
    <section>
      <title>The <literal>Conversation</literal> interface</title>

      <para>The container provides a built-in bean with bean type 
      <literal>Conversation</literal>, scope <literal>@RequestScoped</literal>, 
      and qualifier <literal>@Default</literal>, named 
      <literal>javax.enterprise.context.conversation</literal>.</para>
      
      <programlisting>public interface Conversation {
   public void begin();
   public void begin(String id);
   public void end();
   public String getId();
   public long getTimeout();
   public void setTimeout(long milliseconds);
   public boolean isTransient();
}</programlisting>

      <itemizedlist>
        <listitem>
          <para><literal>begin()</literal> marks the current transient conversation 
          long-running. A conversation identifier may, optionally, be specified. If
          no conversation identifier is specified, an identifier is generated by the
          container.</para>
        </listitem>
        <listitem>
          <para><literal>end()</literal> marks the current long-running conversation 
          transient.</para>
        </listitem>
        <listitem>
          <para><literal>getId()</literal> returns the identifier of the current 
          long-running conversation, or a null value if the current conversation is
          transient.</para>
        </listitem>
        <listitem>
          <para><literal>getTimeout()</literal> returns the timeout, in milliseconds,
          of the current conversation.</para>
        </listitem>
        <listitem>
          <para><literal>setTimeout()</literal> sets the timeout of the current
          conversation.</para>
        </listitem>
        <listitem>
          <para><literal>isTransient()</literal> returns <literal>true</literal> if
          the conversation is marked transient, or <literal>false</literal> if it is
          marked long-running.</para>
        </listitem>
      </itemizedlist>
      
      <para>If any method of <literal>Conversation</literal> is called when the
      conversation scope is not active, a <literal>ContextNotActiveException</literal>
      is thrown.</para>
      
      <para>If <literal>end()</literal> is called, and the current conversation is 
      marked transient, an <literal>IllegalStateException</literal> is thrown.</para>

      <para>If <literal>begin()</literal> is called, and the current conversation is 
      already marked long-running, an <literal>IllegalStateException</literal> is 
      thrown.</para>

      <para>If <literal>begin()</literal> is called with an explicit conversation 
      identifier, and a long-running conversation with that identifier already
      exists, an <literal>IllegalArgumentException</literal> is thrown.</para>

    </section>
    
    <para><emphasis>OPEN ISSUE: </emphasis>The CDI 1.0 spec doesn't define when a 
    context is "initialized" (however the concept is implied), however the CDI spec 
    introduces lifecycle events that require an event to be fired when a context 
    is initialized. Either we need to rewrite the definition of this feature to use 
    the CDI 1.0 language or we need to define when a context is initialized.</para>
    
    <para><emphasis>OPEN ISSUE: </emphasis>What should the event type be for applications
    initialized or destroyed when the application is not a web app?</para>
    
  </section>

</chapter>
